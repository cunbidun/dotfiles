{
  "template": {
    "prefix": "template",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "using namespace std;",
      "",
      "int main() {",
      "  ios_base::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "}",
      ""
    ],
    "description": "template"
  },
  "mod_int": {
    "prefix": "mod_int",
    "body": [
      "struct mod_int {",
      "  int MOD;",
      "  mod_int(int MOD) {",
      "    this->MOD = MOD;",
      "  }",
      "  int add(int x, int y) {",
      "    return ((x + y) >= MOD ? x + y - MOD : x + y);",
      "  }",
      "  int sub(int x, int y) {",
      "    return ((x - y) < 0 ? x - y + MOD : x - y);",
      "  }",
      "  int mul(int x, int y) {",
      "    return (int)((1LL * x * y) % MOD);",
      "  }",
      "  int pow(int x, int p) {",
      "    if (p == 0) {",
      "      return 1;",
      "    }",
      "    int t = pow(x, p / 2);",
      "    if ((p & 1) == 1) {",
      "      return mul(mul(t, t), x);",
      "    }",
      "    return mul(t, t);",
      "  }",
      "  int inv(int x) {",
      "    return pow(x, MOD - 2);",
      "  }",
      "  int div(int x, int y) {",
      "    return mul(x, inv(y));",
      "  }",
      "};",
      ""
    ],
    "description": "basic mod_int"
  },
  "union_find": {
    "prefix": "union_find",
    "body": [
      "struct union_find {",
      "  vector<int> p, child, rank;",
      "  int dsu_size;",
      "  union_find(int _n) {",
      "    dsu_size = _n;",
      "    p.assign(_n, 0);",
      "    rank.assign(_n, 0);",
      "    child.assign(_n, 0);",
      "    for (int i = 0; i < _n; i++) {",
      "      p[i] = i;",
      "      child[i] = 1;",
      "    }",
      "  }",
      "  int find(int i) {",
      "    return (p[i] == i) ? i : (p[i] = find(p[i]));",
      "  }",
      "  bool is_same_set(int x, int y) {",
      "    return find(x) == find(y);",
      "  }",
      "  void merge(int x, int y) {",
      "    if (!is_same_set(x, y)) {",
      "      dsu_size--;",
      "      x = find(x);",
      "      y = find(y);",
      "      if (rank[x] > rank[y]) {",
      "        child[x] += child[y];",
      "        p[y] = x;",
      "      } else {",
      "        p[x] = y;",
      "        child[y] += child[x];",
      "        if (rank[x] == rank[y]) {",
      "          rank[y]++;",
      "        }",
      "      }",
      "    }",
      "  }",
      "  int size(int i) {",
      "    return child[find(i)];",
      "  }",
      "  int num_components() {",
      "    return dsu_size;",
      "  }",
      "};",
      ""
    ],
    "description": "union_find"
  },
  "y_combinator_result": {
    "prefix": "y_combinator_result",
    "body": [
      "namespace std {",
      "template <class Fun>",
      "class y_combinator_result {",
      "  Fun fun_;",
      " public:",
      "  template <class T>",
      "  explicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}",
      "  template <class... Args>",
      "  decltype(auto) operator()(Args &&...args) {",
      "    return fun_(std::ref(*this), std::forward<Args>(args)...);",
      "  }",
      "};",
      "template <class Fun>",
      "decltype(auto) yc(Fun &&fun) {",
      "  return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));",
      "}",
      "}  // namespace std",
      ""
    ],
    "description": "y_combinator_result"
  },
  "dfs_tree": {
    "prefix": "dfs_tree",
    "body": [
      "struct dfs_tree {",
      " public:",
      "  vector<vector<int>> p;",
      "  vector<vector<int>> a;",
      "  vector<int> lvl, c;",
      "  int n;",
      "  dfs_tree() {}",
      "  dfs_tree(int _n) {",
      "    init(_n);",
      "  }",
      "  void init(int _n) {",
      "    n = _n;",
      "    lvl.assign(n, 0);",
      "    c.assign(n, 0);",
      "    p.assign(n, vector<int>(21));",
      "    a.assign(n, vector<int>());",
      "  }",
      "  void add_edge(int u, int v) {",
      "    a[u].push_back(v);",
      "    a[v].push_back(u);",
      "  }",
      "  void dfs(int u, int l = -1) {",
      "    c[u] = 1;",
      "    for (int v : a[u]) {",
      "      if (v != l) {",
      "        p[v][0] = u;",
      "        lvl[v] = lvl[u] + 1;",
      "        dfs(v, u);",
      "        c[u] += c[v];",
      "      }",
      "    }",
      "  }",
      "  void init_lca(int r = 0) {",
      "    dfs(r);",
      "    for (int j = 1; j <= 20; j++) {",
      "      for (int i = 0; i < n; i++) {",
      "        p[i][j] = p[p[i][j - 1]][j - 1];",
      "      }",
      "    }",
      "  }",
      "  int jump(int x, int l) {",
      "    for (int i = 19; i >= 0; i--) {",
      "      if ((l >> i) & 1) {",
      "        x = p[x][i];",
      "      }",
      "    }",
      "    return x;",
      "  }",
      "  int lca(int x, int y) {",
      "    if (lvl[x] > lvl[y]) {",
      "      swap(x, y);",
      "    }",
      "    y = jump(y, lvl[y] - lvl[x]);",
      "    if (x == y) {",
      "      return x;",
      "    }",
      "    for (int i = 19; i >= 0; i--) {",
      "      if (p[y][i] != p[x][i]) {",
      "        x = p[x][i];",
      "        y = p[y][i];",
      "      }",
      "    }",
      "    return p[x][0];",
      "  }",
      "  int dis(int x, int y) {",
      "    int z = lca(x, y);",
      "    return lvl[x] + lvl[y] - 2 * lvl[z];",
      "  }",
      "};",
      ""
    ],
    "description": "dfs_tree"
  },
  "fenwick_tree": {
    "prefix": "fenwick_tree",
    "body": [
      "// fenwick_tree",
      "// 1-based index",
      "template <typename T>",
      "struct fenwick_tree {",
      "  vector<T> bit;",
      "  int n;",
      "  fenwick_tree() {}",
      "  fenwick_tree(int _n) { init(_n); }",
      "  void init(int _n) {",
      "    n = _n;",
      "    bit.assign(n + 1, 0);",
      "  }",
      "  void update(int p, int v) {",
      "    while (p <= n) {",
      "      bit[p] += v;",
      "      p += p & -p;",
      "    }",
      "  }",
      "  T get(int p) {",
      "    int res = 0;",
      "    while (p >= 1) {",
      "      res += bit[p];",
      "      p -= p & -p;",
      "    }",
      "    return res;",
      "  }",
      "  T get(int l, int r) {",
      "    if (l > r) {",
      "      return 0;",
      "    }",
      "    return get(r) - get(l - 1);",
      "  }",
      "};",
      ""
    ],
    "description": "fenwick_tree"
  },
  "segment_tree": {
    "prefix": "segment_tree",
    "body": [
      "template <typename T>",
      "struct segment_tree {",
      "  int n;",
      "  vector<T> st, lazy;",
      "  segment_tree(int _n) : n(_n) {",
      "    st.assign(4 * n, 0);",
      "  }",
      "  void update(int i, int l, int r, int p, int v) {",
      "    if (r < p || p < l) {",
      "      return;",
      "    }",
      "    if (p == l && r == p) {",
      "      st[i] = v;",
      "      return;",
      "    }",
      "    int m = (l + r) / 2;",
      "    update(i * 2 + 1, l, m, p, v);",
      "    update(i * 2 + 2, m + 1, r, p, v);",
      "    st[i] = st[i * 2 + 1] + st[i * 2 + 2];",
      "  }",
      "  T get_sum(int i, int l, int r, int ql, int qr) {",
      "    if (r < ql || qr < l || qr < ql) {",
      "      return 0;",
      "    }",
      "    if (ql <= l && r <= qr) {",
      "      return st[i];",
      "    }",
      "    int m = (l + r) / 2;",
      "    return get_sum(i * 2 + 1, l, m, ql, qr) + get_sum(i * 2 + 2, m + 1, r, ql, qr);",
      "  }",
      "  void update(int p, int v) {",
      "    update(0, 0, n - 1, p, v);",
      "  }",
      "  int get_sum(int L, int R) {",
      "    return get_sum(0, 0, n - 1, L, R);",
      "  }",
      "};",
      ""
    ],
    "description": "segment_tree"
  },
  "debug": {
    "prefix": "debug",
    "body": [
      "template <class c>",
      "struct rge { c b, e; };",
      "template <class c>",
      "rge<c> range(c i, c j) { return rge<c>{i, j}; }",
      "template <class c>",
      "auto dud(c *x) -> decltype(cerr << *x, 0);",
      "template <class c>",
      "char dud(...);",
      "struct debug {",
      "#ifdef LOCAL",
      "  ~debug() { cout << endl; }",
      "  template <class c>",
      "  typename enable_if<sizeof dud<c>(0) != 1, debug &>::type operator<<(c i) {",
      "    cout << boolalpha << i;",
      "    return *this;",
      "  }",
      "  template <class c>",
      "  typename enable_if<sizeof dud<c>(0) == 1, debug &>::type operator<<(c i) {",
      "    return *this << range(begin(i), end(i));",
      "  }",
      "  template <class c, class b>",
      "  debug &operator<<(pair<b, c> d) {",
      "    return *this << \"(\" << d.first << \", \" << d.second << \")\";",
      "  }",
      "  template <class c>",
      "  debug &operator<<(rge<c> d) {",
      "    *this << \"[\";",
      "    for (auto it = d.b; it != d.e; ++it) {",
      "      *this << \", \" + 2 * (it == d.b) << *it;",
      "    }",
      "    return *this << \"]\";",
      "  }",
      "#else",
      "  template <class c>",
      "  debug &operator<<(const c &) { return *this; }",
      "#endif",
      "};",
      "#define imie(...) \"[\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"",
      ""
    ],
    "description": "debug"
  },
  "compressor": {
    "prefix": "compressor",
    "body": [
      "template <class T>",
      "struct compressor {",
      "public:",
      "  vector<T> l;",
      "  map<T, int> mp;",
      "  compressor() {}",
      "  void add(T x) {",
      "    l.push_back(x);",
      "  }",
      "  void compress() {",
      "    sort(l.begin(), l.end());",
      "    l.resize(distance(l.begin(), unique(l.begin(), l.end())));",
      "    for (int i : l)",
      "      mp[i] = (int)mp.size() + 1;",
      "  }",
      "  int get(T x) {",
      "    return mp[x];",
      "  }",
      "  int size() {",
      "    return (int)mp.size();",
      "  }",
      "};",
      ""
    ],
    "description": "compressor"
  }
}
