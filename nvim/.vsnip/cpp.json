{
  "template": {
    "prefix": "template",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "using namespace std;",
      "",
      "int main() {",
      "  ios_base::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "}",
      ""
    ],
    "description": "template"
  },
  "mod_int": {
    "prefix": "mod_int",
    "body": [
      "struct mod_int {",
      "  int MOD;",
      "  mod_int(int MOD) {",
      "    this->MOD = MOD;",
      "  }",
      "  int add(int x, int y) {",
      "    return ((x + y) >= MOD ? x + y - MOD : x + y);",
      "  }",
      "  int sub(int x, int y) {",
      "    return ((x - y) < 0 ? x - y + MOD : x - y);",
      "  }",
      "  int mul(int x, int y) {",
      "    return (int)((1LL * x * y) % MOD);",
      "  }",
      "  int pow(int x, int p) {",
      "    if (p == 0) {",
      "      return 1;",
      "    }",
      "    int t = pow(x, p / 2);",
      "    if ((p & 1) == 1) {",
      "      return mul(mul(t, t), x);",
      "    }",
      "    return mul(t, t);",
      "  }",
      "  int inv(int x) {",
      "    return pow(x, MOD - 2);",
      "  }",
      "  int div(int x, int y) {",
      "    return mul(x, inv(y));",
      "  }",
      "};",
      ""
    ],
    "description": "basic mod_int"
  },
  "union_find": {
    "prefix": "union_find",
    "body": [
      "struct union_find {",
      "  typedef vector<int> vi;",
      "  vi p, sz, rank;",
      "  int dsu_size;",
      "  union_find(int _n) : p(vi(_n)), sz(vi(_n, 1)), rank(vi(_n)), dsu_size(_n) {",
      "    for (int i = 0; i < _n; i++) {",
      "      p[i] = i;",
      "    }",
      "  }",
      "  int find(int i) { return (p[i] == i) ? i : (p[i] = find(p[i])); }",
      "  bool is_same_set(int x, int y) { return find(x) == find(y); }",
      "  void merge(int x, int y) {",
      "    if (!is_same_set(x, y)) {",
      "      dsu_size--;",
      "      x = find(x), y = find(y);",
      "      if (rank[x] > rank[y]) {",
      "        p[y] = x, sz[x] += sz[y];",
      "      } else {",
      "        p[x] = y, sz[y] += sz[x];",
      "        rank[y] += (rank[x] == rank[y]);",
      "      }",
      "    }",
      "  }",
      "  int size(int i) { return sz[find(i)]; }",
      "};",
      ""
    ],
    "description": "union_find"
  },
  "y_combinator_result": {
    "prefix": "y_combinator_result",
    "body": [
      "namespace std {",
      "template <class Fun>",
      "class y_combinator_result {",
      "  Fun fun_;",
      " public:",
      "  template <class T>",
      "  explicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}",
      "  template <class... Args>",
      "  decltype(auto) operator()(Args &&...args) {",
      "    return fun_(std::ref(*this), std::forward<Args>(args)...);",
      "  }",
      "};",
      "template <class Fun>",
      "decltype(auto) yc(Fun &&fun) {",
      "  return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));",
      "}",
      "}  // namespace std",
      ""
    ],
    "description": "y_combinator_result"
  },
  "dfs_tree": {
    "prefix": "dfs_tree",
    "body": [
      "struct dfs_tree {",
      " public:",
      "  vector<vector<int>> p;",
      "  vector<vector<int>> a;",
      "  vector<int> lvl, c;",
      "  int n;",
      "  dfs_tree() {}",
      "  dfs_tree(int _n) {",
      "    init(_n);",
      "  }",
      "  void init(int _n) {",
      "    n = _n;",
      "    lvl.assign(n, 0);",
      "    c.assign(n, 0);",
      "    p.assign(n, vector<int>(21));",
      "    a.assign(n, vector<int>());",
      "  }",
      "  void add_edge(int u, int v) {",
      "    a[u].push_back(v);",
      "    a[v].push_back(u);",
      "  }",
      "  void dfs(int u, int l = -1) {",
      "    c[u] = 1;",
      "    for (int v : a[u]) {",
      "      if (v != l) {",
      "        p[v][0] = u;",
      "        lvl[v] = lvl[u] + 1;",
      "        dfs(v, u);",
      "        c[u] += c[v];",
      "      }",
      "    }",
      "  }",
      "  void init_lca(int r = 0) {",
      "    dfs(r);",
      "    for (int j = 1; j <= 20; j++) {",
      "      for (int i = 0; i < n; i++) {",
      "        p[i][j] = p[p[i][j - 1]][j - 1];",
      "      }",
      "    }",
      "  }",
      "  int jump(int x, int l) {",
      "    for (int i = 19; i >= 0; i--) {",
      "      if ((l >> i) & 1) {",
      "        x = p[x][i];",
      "      }",
      "    }",
      "    return x;",
      "  }",
      "  int lca(int x, int y) {",
      "    if (lvl[x] > lvl[y]) {",
      "      swap(x, y);",
      "    }",
      "    y = jump(y, lvl[y] - lvl[x]);",
      "    if (x == y) {",
      "      return x;",
      "    }",
      "    for (int i = 19; i >= 0; i--) {",
      "      if (p[y][i] != p[x][i]) {",
      "        x = p[x][i];",
      "        y = p[y][i];",
      "      }",
      "    }",
      "    return p[x][0];",
      "  }",
      "  int dis(int x, int y) {",
      "    int z = lca(x, y);",
      "    return lvl[x] + lvl[y] - 2 * lvl[z];",
      "  }",
      "};",
      ""
    ],
    "description": "dfs_tree"
  },
  "segment_tree": {
    "prefix": "segment_tree",
    "body": [
      "template <typename T>",
      "struct segment_tree {",
      "  int n;",
      "  vector<T> st, lazy;",
      "  segment_tree(int _n) : n(_n) {",
      "    st.assign(8 * n, 0);",
      "  }",
      "  void update(int i, int l, int r, int p, T v) {",
      "    if (r < p || p < l) {",
      "      return;",
      "    }",
      "    if (p == l && r == p) {",
      "      st[i] = v;",
      "      return;",
      "    }",
      "    int m = (l + r) / 2;",
      "    update(i * 2 + 1, l, m, p, v);",
      "    update(i * 2 + 2, m + 1, r, p, v);",
      "    st[i] = min(st[i * 2 + 1], st[i * 2 + 2]);",
      "  }",
      "  T get_min(int i, int l, int r, int ql, int qr) {",
      "    if (r < ql || qr < l || qr < ql) {",
      "      return 1e18;",
      "    }",
      "    if (ql <= l && r <= qr) {",
      "      return st[i];",
      "    }",
      "    int m = (l + r) / 2;",
      "    return min(get_min(i * 2 + 1, l, m, ql, qr), get_min(i * 2 + 2, m + 1, r, ql, qr));",
      "  }",
      "  void update(int p, T v) {",
      "    update(0, 0, n - 1, p, v);",
      "  }",
      "  T get_min(int L, int R) {",
      "    return get_min(0, 0, n - 1, L, R);",
      "  }",
      "};",
      ""
    ],
    "description": "segment_tree"
  },
  "debug": {
    "prefix": "debug",
    "body": [
      "template <class c>",
      "struct rge { c b, e; };",
      "template <class c>",
      "rge<c> range(c i, c j) { return rge<c>{i, j}; }",
      "template <class c>",
      "auto dud(c *x) -> decltype(cerr << *x, 0);",
      "template <class c>",
      "char dud(...);",
      "struct debug {",
      "#ifdef LOCAL",
      "  ~debug() { cout << endl; }",
      "  template <class c>",
      "  typename enable_if<sizeof dud<c>(0) != 1, debug &>::type operator<<(c i) {",
      "    cout << boolalpha << i;",
      "    return *this;",
      "  }",
      "  template <class c>",
      "  typename enable_if<sizeof dud<c>(0) == 1, debug &>::type operator<<(c i) {",
      "    return *this << range(begin(i), end(i));",
      "  }",
      "  template <class c, class b>",
      "  debug &operator<<(pair<b, c> d) {",
      "    return *this << \"(\" << d.first << \", \" << d.second << \")\";",
      "  }",
      "  template <class c>",
      "  debug &operator<<(rge<c> d) {",
      "    *this << \"[\";",
      "    for (auto it = d.b; it != d.e; ++it) {",
      "      *this << \", \" + 2 * (it == d.b) << *it;",
      "    }",
      "    return *this << \"]\";",
      "  }",
      "#else",
      "  template <class c>",
      "  debug &operator<<(const c &) { return *this; }",
      "#endif",
      "};",
      "#define imie(...) \"[\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"",
      ""
    ],
    "description": "debug"
  },
  "compressor": {
    "prefix": "compressor",
    "body": [
      "template <class T>",
      "struct compressor {",
      "public:",
      "  vector<T> l;",
      "  map<T, int> mp;",
      "  compressor() {}",
      "  void add(T x) {",
      "    l.push_back(x);",
      "  }",
      "  void compress() {",
      "    sort(l.begin(), l.end());",
      "    l.resize(distance(l.begin(), unique(l.begin(), l.end())));",
      "    for (int i : l)",
      "      mp[i] = (int)mp.size() + 1;",
      "  }",
      "  int get(T x) {",
      "    return mp[x];",
      "  }",
      "  int size() {",
      "    return (int)mp.size();",
      "  }",
      "};",
      ""
    ],
    "description": "compressor"
  },
  "fenwick_tree": {
    "prefix": "fenwick_tree",
    "body": [
      "// fenwick_tree",
      "// 1-based index",
      "template <typename T>",
      "struct fenwick_tree {",
      "  vector<T> bit;",
      "  int n;",
      "  fenwick_tree() {}",
      "  fenwick_tree(int _n) { init(_n); }",
      "  void init(int _n) {",
      "    n = _n, bit.assign(n + 1, T{});",
      "  }",
      "  void update(int p, T v) {",
      "    while (p <= n) {",
      "      bit[p] += v, p += p & -p;",
      "    }",
      "  }",
      "  T get(int p) {",
      "    T res{};",
      "    while (p >= 1) {",
      "      res += bit[p], p -= p & -p;",
      "    }",
      "    return res;",
      "  }",
      "  T get(int l, int r) { return (l > r) ? T{} : get(r) - get(l - 1); }",
      "};",
      ""
    ],
    "description": "fenwick_tree"
  },
  "fenwick_tree_range": {
    "prefix": "fenwick_tree_range",
    "body": [
      "// 1-based index: range update point query",
      "template <typename T>",
      "struct fenwick_tree_range {",
      "  vector<T> bit;",
      "  int n;",
      "  fenwick_tree_range() {}",
      "  fenwick_tree_range(int _n) { init(_n); }",
      "  void init(int _n) {",
      "    n = _n, bit.assign(n + 1, T{});",
      "  }",
      "  void update(int p, T v) {",
      "    while (p <= n) {",
      "      bit[p] += v, p += p & -p;",
      "    }",
      "  }",
      "  void update(int l, int r, T v) {",
      "    update(l, v);",
      "    update(r + 1, -v);",
      "  }",
      "  T get(int p) {",
      "    T res{};",
      "    while (p >= 1) {",
      "      res += bit[p], p -= p & -p;",
      "    }",
      "    return res;",
      "  }",
      "};",
      ""
    ],
    "description": "fenwick_tree_range"
  },
  "longest_nondec_subseq": {
    "prefix": "longest_nondec_subseq",
    "body": [
      "int longest_nondec_subseq(std::vector<int> &v) {",
      "  const int INF = 1000000000;",
      "  int n = v.size();",
      "  vector<int> d(n + 1, INF);",
      "  for (int i = 0; i < n; i++) {",
      "    *upper_bound(d.begin(), d.end(), v[i]) = v[i];",
      "  }",
      "  int r = 0;",
      "  for (int i = 0; i <= n; i++) {",
      "    if (d[i] == INF) {",
      "      r = i;",
      "      break;",
      "    }",
      "  }",
      "  return r;",
      "}",
      ""
    ],
    "description": "longest_nondec_subseq"
  },
  "segtree_rsum_rmin": {
    "prefix": "segtree_rsum_rmin",
    "body": [
      "// 0-indexed",
      "template <typename T>",
      "struct segtree_rsum_rmin {",
      "  int n;",
      "  vector<T> st, lazy;",
      "  segtree_rsum_rmin(int _n) : n(_n) {",
      "    st.assign(8 * n, T{});",
      "    lazy.assign(8 * n, T{});",
      "  }",
      "  void lazy_prop(int i, int l, int r) {",
      "    if (lazy[i] != 0) {",
      "      st[i] += lazy[i];",
      "      if (l != r) {",
      "        lazy[i * 2 + 1] += lazy[i];",
      "        lazy[i * 2 + 2] += lazy[i];",
      "      }",
      "    }",
      "    lazy[i] = 0;",
      "  }",
      "",
      "  void update(int i, int l, int r, int ql, int qr, T v) {",
      "    lazy_prop(i, l, r);",
      "    if (r < ql || qr < l) {",
      "      return;",
      "    }",
      "    if (ql <= l && r <= qr) {",
      "      lazy[i] += v;",
      "      lazy_prop(i, l, r);",
      "      return;",
      "    }",
      "    int m = (l + r) / 2;",
      "    update(i * 2 + 1, l, m, ql, qr, v);",
      "    update(i * 2 + 2, m + 1, r, ql, qr, v);",
      "    st[i] = min(st[i * 2 + 1], st[i * 2 + 2]);",
      "  }",
      "",
      "  T get_min(int i, int l, int r, int ql, int qr) {",
      "    lazy_prop(i, l, r);",
      "    if (r < ql || qr < l || qr < ql) {",
      "      return numeric_limits<long long>::max();",
      "    }",
      "    if (ql <= l && r <= qr) {",
      "      return st[i];",
      "    }",
      "    int m = (l + r) / 2;",
      "    return min(get_min(i * 2 + 1, l, m, ql, qr), get_min(i * 2 + 2, m + 1, r, ql, qr));",
      "  }",
      "  void update(int l, int r, T v) {",
      "    update(0, 0, n - 1, l, r, v);",
      "  }",
      "  T get_min(int l, int r) {",
      "    return get_min(0, 0, n - 1, l, r);",
      "  }",
      "};",
      ""
    ],
    "description": "segtree_rsum_rmin"
  },
  "sparse_table": {
    "prefix": "sparse_table",
    "body": [
      "template <typename T, class F = function<T(const T &, const T &)>>",
      "class sparse_table {",
      "public:",
      "  int N;",
      "  vector<vector<T>> st;",
      "  F func;",
      "  sparse_table(const vector<T> &a, const F &f) : func(f) {",
      "    N = static_cast<int>(a.size());",
      "    int max_log = 32 - __builtin_clz(N);",
      "    st.resize(N, vector<T>(max_log));",
      "    for (int i = 0; i < N; i++) {",
      "      st[i][0] = a[i];",
      "    }",
      "    for (int j = 1; j < max_log; j++) {",
      "      for (int i = 0; i + (1 << (j - 1)) < N; i++) {",
      "        st[i][j] = func(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);",
      "      }",
      "    }",
      "  }",
      "  T get(int l, int r) const {",
      "    assert(0 <= l && l <= r && r <= N - 1);",
      "    int k = log2(r - l + 1);",
      "    return func(st[l][k], st[r - (1 << k) + 1][k]);",
      "  }",
      "};",
      ""
    ],
    "description": "sparse_table"
  },
  "mint_nck": {
    "prefix": "mint_nck",
    "body": [
      "struct mint_nck {",
      "  int N;",
      "  vector<mint> f, invf;",
      "  mint_nck(int _n) : N(_n) {",
      "    f.assign(N + 1, 0), invf.assign(N + 1, 0);",
      "    f[0] = 1;",
      "    for (int i = 1; i <= N; i++) {",
      "      f[i] = f[i - 1] * i;",
      "    }",
      "    invf[N] = pow(f[N], MOD - 2);",
      "    for (int i = N - 1; i >= 0; i--) {",
      "      invf[i] = invf[i + 1] * (i + 1);",
      "    }",
      "  }",
      "  mint get(int n, int k) {",
      "    assert(0 <= n && n <= N && 0 <= k && k <= N);",
      "    return (n < k) ? 0 : f[n] * invf[k] * invf[n - k];",
      "  }",
      "};",
      ""
    ],
    "description": "mint_nck"
  },
  "b_pow": {
    "prefix": "b_pow",
    "body": [
      "template <typename T>",
      "T b_pow(T a, long long b) {",
      "  assert(b >= 0);",
      "  T r = 1;",
      "  while (b) {",
      "    if (b & 1) {",
      "      r *= a;",
      "    }",
      "    b >>= 1, a *= a;",
      "  }",
      "  return r;",
      "}",
      ""
    ],
    "description": "b_pow"
  },
  "mint": {
    "prefix": "mint",
    "body": [
      "template <typename T>",
      "T mod_inv(T a, T m) {",
      "  // assert(__gcd(a, m) == 1);",
      "  a %= m;",
      "  a = a < 0 ? a + m : a;",
      "  T x = a, y = m, vx = 1, vy = 0;",
      "  while (x) {",
      "    T k = y / x;",
      "    y %= x, vy -= k * vx;",
      "    swap(x, y), swap(vx, vy);",
      "  }",
      "  assert(y == 1);",
      "  return vy < 0 ? m + vy : vy;",
      "}",
      "",
      "template <int MOD>",
      "struct mint {",
      "private:",
      "  int v;",
      "  explicit operator int() const { return v; }",
      "",
      "public:",
      "  mint() { v = 0; }",
      "  mint(long long _v) {",
      "    v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
      "    if (v < 0) { // explicit -> don't silently convert to int",
      "      v += MOD;",
      "    }",
      "  }",
      "  friend std::ostream &operator<<(std::ostream &out, const mint &n) { return out << int(n); }",
      "  friend std::istream &operator>>(std::istream &in, mint &n) {",
      "    long long v_;",
      "    in >> v_;",
      "    n = mint(v_);",
      "    return in;",
      "  }",
      "  mint pow(long long p) const {",
      "    assert(p >= 0);",
      "    mint res = 1, a = v;",
      "    assert(p >= 0);",
      "    for (; p; p /= 2, a *= a) {",
      "      if (p & 1) {",
      "        res *= a;",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "  mint inv() const {",
      "    mint res;",
      "    res.v = mod_inv(v, MOD);",
      "    return res;",
      "  }",
      "  friend mint inv(const mint &a) { return a.inv(); }",
      "  mint &operator+=(const mint &m) {",
      "    if ((v += m.v) >= MOD) {",
      "      v -= MOD;",
      "    }",
      "    return *this;",
      "  }",
      "  mint &operator-=(const mint &m) {",
      "    if ((v -= m.v) < 0) {",
      "      v += MOD;",
      "    }",
      "    return *this;",
      "  }",
      "  mint &operator*=(const mint &m) {",
      "    v = 1LL * v * m.v % MOD;",
      "    return *this;",
      "  }",
      "  mint &operator/=(const mint &m) { return (*this) *= m.inv(); }",
      "  mint operator-() const { return mint(-v); }",
      "  mint &operator++() { return *this += 1; }",
      "  mint &operator--() { return *this -= 1; }",
      "  mint operator++(int) {",
      "    mint result = *this;",
      "    ++*this;",
      "    return result;",
      "  }",
      "  mint operator--(int) {",
      "    mint result = *this;",
      "    --*this;",
      "    return result;",
      "  }",
      "  friend bool operator==(const mint &a, const mint &b) { return a.v == b.v; }",
      "  friend bool operator!=(const mint &a, const mint &b) { return !(a == b); }",
      "  friend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }",
      "  friend mint operator+(mint a, const mint &b) { return a += b; }",
      "  friend mint operator-(mint a, const mint &b) { return a -= b; }",
      "  friend mint operator*(mint a, const mint &b) { return a *= b; }",
      "  friend mint operator/(mint a, const mint &b) { return a /= b; }",
      "};",
      ""
    ],
    "description": "mint"
  },
  "segtree_rset_rmax": {
    "prefix": "segtree_rset_rmax",
    "body": [
      "// 0-indexed",
      "template <typename T>",
      "struct segtree_rset_rmax {",
      "  int n;",
      "  vector<pair<T, int>> st, lazy;",
      "  segtree_rset_rmax(int _n) : n(_n) {",
      "    st = lazy = vector<pair<T, int>>(4 * n, {T{}, 0});",
      "  }",
      "  void lazy_prop(int i, int l, int r) {",
      "    if (lazy[i].first != 0) {",
      "      st[i] = lazy[i];",
      "      if (l != r) {",
      "        lazy[i * 2 + 1] = lazy[i];",
      "        lazy[i * 2 + 2] = lazy[i];",
      "      }",
      "    }",
      "    lazy[i].first = 0;",
      "  }",
      "",
      "  void update(int i, int l, int r, int ql, int qr, T v, int id) {",
      "    lazy_prop(i, l, r);",
      "    if (r < ql || qr < l) {",
      "      return;",
      "    }",
      "    if (ql <= l && r <= qr) {",
      "      lazy[i] = {v, id};",
      "      lazy_prop(i, l, r);",
      "      return;",
      "    }",
      "    int m = (l + r) / 2;",
      "    update(i * 2 + 1, l, m, ql, qr, v, id);",
      "    update(i * 2 + 2, m + 1, r, ql, qr, v, id);",
      "    st[i] = max(st[i * 2 + 1], st[i * 2 + 2]);",
      "  }",
      "",
      "  pair<T, int> get_max(int i, int l, int r, int ql, int qr) {",
      "    lazy_prop(i, l, r);",
      "    if (r < ql || qr < l || qr < ql) {",
      "      return {numeric_limits<T>::min(), 0};",
      "    }",
      "    if (ql <= l && r <= qr) {",
      "      return {st[i].first, st[i].second};",
      "    }",
      "    int m = (l + r) / 2;",
      "    return max(get_max(i * 2 + 1, l, m, ql, qr), get_max(i * 2 + 2, m + 1, r, ql, qr));",
      "  }",
      "  void update(int l, int r, T v, int id) {",
      "    update(0, 0, n - 1, l, r, v, id);",
      "  }",
      "  pair<T, int> get_max(int l, int r) {",
      "    return get_max(0, 0, n - 1, l, r);",
      "  }",
      "};",
      ""
    ],
    "description": "segtree_rset_rmax"
  },
  "max_flow": {
    "prefix": "max_flow",
    "body": [
      "template <class T>",
      "struct max_flow {",
      "  const T INF = numeric_limits<T>::max();",
      "",
      "  struct flow_edge {",
      "    int u, v;",
      "    T c, f = T{};",
      "    flow_edge(int _u, int _v, T _c) : u(_u), v(_v), c(_c) {}",
      "  };",
      "",
      "  vector<flow_edge> edges;",
      "  vector<vector<int>> adj;",
      "  int n, m = 0, s, t;",
      "  vector<int> lvl, ptr;",
      "  queue<int> q;",
      "",
      "  max_flow(int _n) : n(_n) {",
      "    adj.resize(_n), lvl.resize(_n), ptr.resize(_n);",
      "  }",
      "",
      "  void add_edge(int u, int v, T cap) {",
      "    edges.push_back({u, v, cap}), edges.push_back({v, u, 0});",
      "    adj[u].push_back(m++), adj[v].push_back(m++);",
      "  }",
      "",
      "  bool bfs() {",
      "    fill(ptr.begin(), ptr.end(), 0);",
      "    fill(lvl.begin(), lvl.end(), -1);",
      "    lvl[s] = 0;",
      "    q.push(s);",
      "    while (!q.empty()) {",
      "      int u = q.front();",
      "      q.pop();",
      "      for (int id : adj[u]) {",
      "        if (edges[id].c > edges[id].f && lvl[edges[id].v] == -1) {",
      "          lvl[edges[id].v] = lvl[u] + 1, q.push(edges[id].v);",
      "        }",
      "      }",
      "    }",
      "    return lvl[t] != -1;",
      "  }",
      "",
      "  T dfs(int u, T pushed) {",
      "    if (pushed == 0) {",
      "      return 0;",
      "    }",
      "    if (u == t) {",
      "      return pushed;",
      "    }",
      "    for (int &cid = ptr[u]; cid < (int)adj[u].size(); cid++) {",
      "      int id = adj[u][cid];",
      "      int v = edges[id].v;",
      "      if (lvl[u] + 1 == lvl[v]) {",
      "        if (T tr = dfs(v, min(pushed, edges[id].c - edges[id].f))) {",
      "          edges[id].f += tr;",
      "          edges[id ^ 1].f -= tr;",
      "          return tr;",
      "        }",
      "      }",
      "    }",
      "    return 0;",
      "  }",
      "",
      "  T cal_max_flow(int _s, int _t) {",
      "    s = _s, t = _t;",
      "    T f = 0;",
      "    while (bfs()) {",
      "      while (T pushed = dfs(s, INF)) {",
      "        f += pushed;",
      "      }",
      "    }",
      "    return f;",
      "  }",
      "};",
      ""
    ],
    "description": "max_flow"
  }
}
